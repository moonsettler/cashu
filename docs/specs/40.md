# NUT-40: Notation and Models

Sending user: `Alice`
Receiving user: `Carol`
Mint: `Bob`

## Bob (mint)

- `m` id of the mint (hash of the mint's descriptor)
- `k` private key of mint (one for each amount)
- `K` public key of mint (`K = kG`)
- `Q` promise (blinded signature)

## Alice (user)

- `r` private key (blinding factor)
- `x` secret derived from `r` via one way function, corresponds to point `Y` on curve
- `T` blinded message
- `Z` proof (unblinded signature)

# Blind Diffie-Hellmann key exchange (BDHKE)

- `Bob` (also known as mint `m`) publishes `K = kG`
- `Alice` picks private key `r`
- `Alice` computes `x = hmac(m, r)` and computes `Y = hash_to_curve(x)`
- `Alice` sends to `Bob`: `T = Y + rG` with `r` (**blinding**)
- `Bob` sends back to `Alice` blinded key: `Q = kT` (these two steps are the DH key exchange) (**signing**)
- `Alice` can calculate the unblinded key as `Q - rK = kY + krG - krG = kY = Z` (**unblinding**)
- Alice can take the pair `(x, Z)` as a token and can send it to `Carol`.
- `Carol` can send `(x, Z)` to `Bob` who then checks that `k*hash_to_curve(x) == Z` (**verification**), and if so treats it as a valid spend of a token, adding `x`  to the list of spent secrets.

# Chaum-Pedersen Commitment (DLEQ)

## Bob (mint) creates DLEQ proof
- `p` random nonce
- `R1 = P = pG`
- `R2 = pT` where `T` is the blinded message `Y + rG`
- `e = hash(R1, R2, K, Q)`
- `s = p + ek`

`Bob` reveales to `Alice` the following vector: `(Q, e, s)`

## Alice (user) verifies DLEQ proof
- `R1 = sG - eK`
- `R2 = sT - eQ`

`Alice` then checks `e == hash(R1, R2, K, Q)` to ensure `Bob` signed with private key `k` preventing secret tagging or deniability on `Q`.

`Alice` reveales to `Carol` the following vector: `(m, r, Q, e, s)`

## Carol (user) computes blind signature and verifies DLEQ proof
- `x = hmac(m, r)`
- `Z = Q - rK`
- `T = hash_to_curve(x) + rG`
- `R1 = sG - eK`
- `R2 = sT - eQ`
- `e == hash(R1, R2, K, Q)` (**verification**)

`Carol` reveales to `Bob` the following vector: `(x, Z)` where `k*hash_to_curve(x) == Z`

`Bob` is unable to link `T` (or `Q`)  to `x` and `Z` without knowing `r` which is only known to `Alice` and `Carol`.

# Fraud Proofs

- `x` secret derived from `r` via one way function, corresponds to point `Y` on curve
- `B'` blinded message
- `C'` promise (blinded signature)
- `C` proof (unblinded signature)

**Problem:** When `Alice` (interchangeable with `Carol`) gives `Bob` the token `(x, C)`, `Bob` may include this token in his burn attestation, but he may choose to not honor his side in the transaction, like paying an lightning invoice, or handing out new ecash tokens in exchange. `Bob` can steal from `Alice`, and `Alice` has no way to prove it.

**Solution:** Make `Bob` sign a *committment* to a transaction he will carry out if some specific secret is revealed by `Alice`. *(Generally it would be a set of secrets, but for the sake of simplicity we will describe the schemes with a singular token)*

**Summary:** Instead of revealing `x`, `Alice` gives `Bob` the value `Y` which is calculated using a one way function as `hash_to_curve(x)`. Since `kY = C`, and `k` is the private key `Bob` knows, he can verify that the point `Y` and the blind signature `C` are not forgeries, but if challenged, he can not produce the value `x`, that is only known to `Alice` for now.

**Challenge-response scheme:** `Bob` has a reputation to uphold, `Alice` can make him commit to statements that he can not reneg on, after signing an answer. `Bob` has a strong incentive to answer truthfully, otherwise he may proven to be a liar and a fraud.

**Public challenge:** in case `Bob` does not respond to a private challenge by `Alice`, she can challenge `Bob` in the *court of public* as in openly on a public forum. By ignoring this challenge or abandoning it prematurely `Bob` would admit to fraud to any observers of the proof session.

## Minting Notes Fraud Proof
1. After `Bob` signed a commitment to a transaction, which in this case requires `Alice` paying a lightning invoice, what he signs is that he will give `Alice` the `C'` for her `B' (+DLEQ proof)` if the invoice is paid. More precisely if the `payment_secret` preimage for the sha256 `payment_hash` is revealed to him.
2. `Alice` by paying the invoice receives the `payment_secret` the `payment_hash` in the invoice, normally she gets `C' + DLEQ`.
3. If `Bob` tries to defraud `Alice`, she will publish his signed message (which contains the `payment_hash`), and the `payment_secret`, proving she has completed her duty.
4. Then `Bob` has to publish in defense the DLEQ including `C'`
5. This allows `Aice` to get `(x, C)`

## Spending Notes Fraud Proof
1. `Alice` shall not reveal `x` when asking the mint if `Bob` will honor a note or not! Make `Bob` sign the answer with his key!
2. If the answer is yes, ask `Bob` to sign a commitment to `Alice's` transaction, that he will honor it (can be an ln invoice), if `Alice` gives `Bob` the secret!
3. If `Bob` signs the commitment but does not carry out his end it becomes provable (to different degrees)
4. If `Bob` lies about his blind signature `Alice` can publicly shame him with her DLEQ proof
5. `Bob` can prove when he paid an ln invoice such a 'receipt' is possible. so the mint can be challenged to show receipt (preimage?). in case of an on-chain tx it's trivial to check if the recipient address got the funds.

## Exchange Notes Fraud Proof
1. After `Bob` signed a commitment to a transaction, which in this case is a note swap, what he signs is that he will give `Alice` the `C'` for her `B' (+DLEQ proof)` if the previous `x0` is revealed to him.
2. `Alice` reveals `x0` to `Bob`, normally she gets `C' + DLEQ`.
3. If `Bob` tries to defraud `Alice`, she will publish his signed message and `x0`
4. Then `Bob` has to publish in defense the DLEQ including `C'`
5. This allows `Aice` to get `(x, C)`